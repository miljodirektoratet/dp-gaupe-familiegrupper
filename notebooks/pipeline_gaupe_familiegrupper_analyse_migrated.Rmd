---
title: "Lynx Family Groups Pipeline"
author: "Miljodirektoratet"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: show
---

# Lynx Family Groups Analysis Pipeline

This notebook walks through the spatial analysis and grouping of lynx family
observations, using custom clustering and interactive mapping. The main steps include:

1. Loading and exploring test data
2. Comparing grouping methods (sensitivity analysis)
3. Grouping observations with optimal configuration
4. Creating visualization objects
5. Interactive mapping
6. Exporting results (user controls where/how)

## 1. Setup and Load Libraries

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE
)

# Clear workspace
rm(list = ls())
```

```{r load-libraries}
# Detect base path first (needed for loading package)
if (grepl("/home/rstudio/workspace", getwd())) {
  base_path <- "/home/rstudio/workspace"
} else {
  base_path <- "/home/wilaca/git/miljodirektoratet/dp-gaupe-familiegrupper"
}

cat("Base path set to:", base_path, "\n")
cat("Current working directory:", getwd(), "\n")

# Load gaupefam package (development version)
devtools::load_all(base_path)

# Load other required packages
library(sf) # Spatial data handling
library(dplyr) # Data manipulation
library(leaflet) # Interactive maps
library(htmlwidgets) # Save interactive maps
library(viridis) # Color palettes
library(arrow) # For reading Parquet files

# Enable s2 for spherical geometry
sf::sf_use_s2(TRUE)

# Print software versions
cat("GEOS version:", sf::sf_extSoftVersion()["GEOS"], "\n")
cat("GDAL version:", sf::sf_extSoftVersion()["GDAL"], "\n")
cat("PROJ version:", sf::sf_extSoftVersion()["PROJ"], "\n")
```

## 2. Load and Explore Data



```{r load-data}
# Read spatial datasets
date <- "20260204"
time <- "150247"

docker_data_path <- "/home/rstudio/workspace/dump/hidden/data/"
linux_data_path <- "/home/wilaca/git/miljodirektoratet/dp-gaupe-familiegrupper/dump/hidden/data/"

data_base_path <- if (grepl("/home/rstudio/workspace", getwd())) {
  docker_data_path
} else {
  linux_data_path
}

dat_pnt <- read_parquet(paste0(data_base_path, date, "/input/gaupegruppering_rovviltobservasjon_pkt_", date, "_", time, ".parquet"))
dat_spor <- read_parquet(paste0(data_base_path, date, "/input/gaupegruppering_rovviltobservasjon_spor_lin_", date, "_", time, ".parquet"))
dat_spor_pnt <- read_parquet(paste0(data_base_path, date, "/input/gaupegruppering_rovviltobservasjon_spor_pkt_", date, "_", time, ".parquet"))
dod <- read_parquet(paste0(data_base_path, date, "/input/gaupegruppering_doede_rovdyr_pkt_", date, "_", time, ".parquet"))

# Grouping data
datagrunnlag <- read_parquet(paste0(data_base_path, date, "/input/gaupe_familiegrupper_datagrunnlag_pkt_", date, "_", time, ".parquet"))

# Prey data (different location)
prey_base_path <- if (grepl("/home/rstudio/workspace", getwd())) {
  "/home/rstudio/workspace/dump/hidden/data/"
} else {
  "/home/wilaca/git/miljodirektoratet/dp-gaupe-familiegrupper/dump/hidden/data/"
}
prey <- st_read(paste0(prey_base_path, "byttedyrkategori_shp/byttedyrkategori_skandinavia_tettede_hull.shp"))
```

```{r inspect-observations-data, fig.width=10, fig.height=8}
# Observations data
# Observasjoner: original observations as POINT geometries.
# Dead animals (dod) and observasjoner (dat_pnt), observations include both syns- and sporobservasjoner.
# Sporobservasjoner are represented as points.
# Convert to sf objects first
dat_pnt_sf <- st_as_sf(dat_pnt)
dod_sf <- st_as_sf(dod)

obs_pnt <- bind_rows(dat_pnt_sf, dod_sf)
obs_pnt <- obs_pnt %>% st_cast("POINT")

# Ensure CRS is set (use same as dat which will be loaded later, or set explicitly)
if (is.na(st_crs(obs_pnt))) {
  # Assuming Norwegian projection (EPSG:25833 - ETRS89 / UTM zone 33N)
  obs_pnt <- st_set_crs(obs_pnt, 25833)
}

# Print unique count of rovbase_id
unique_rovbase_ids <- length(unique(obs_pnt$rovbase_id))
cat("Unique rovbase_id:", unique_rovbase_ids, "\n")

head(obs_pnt, 2)
```

```{r inspect-datagrunnlag, fig.width=10, fig.height=8}
# Datagrunnlag = input for grouping analysis
dat <- st_as_sf(datagrunnlag)

# Print unique count of rovbase_id
unique_rovbase_ids <- length(unique(dat$rovbase_id))
cat("Unique rovbase_id:", unique_rovbase_ids, "\n")

head(dat, 2)

# Check the data
cat("Number of observations:", nrow(dat), "\n")
print(dat)
```

```````{r plot-data, fig.width=10, fig.height=8}
# Simple plot of test data
par(mfrow = c(1, 2))

# Plot 1: Spatial distribution
plot(st_geometry(dat),
  pch = 19, col = "red", cex = 2,
  main = "Spatial Distribution", axes = TRUE
)

# Plot 2: Temporal distribution
plot(dat$datotid_fra, 1:nrow(dat),
  pch = 19, col = "blue", cex = 2,
  main = "Temporal Distribution",
  xlab = "Date", ylab = "Observation ID",
  yaxt = "n"
)
axis(2, at = 1:nrow(dat), labels = dat$rovbase_id)
segments(dat$datotid_fra, 1:nrow(dat),
  dat$datotid_til, 1:nrow(dat),
  col = "blue", lwd = 2
)

par(mfrow = c(1, 1))
```

## 3. Group Observations (Automatic Configuration Selection)

```{r group-observations}
# cat("Running analysis to find optimal configuration...\n\n")

# # Compare methods and automatically select best
# # To test only one clustering method (faster), use clustering_methods = "custom" or "hierarchical"
# comparison <- compare_grouping_methods(
#   data = dat,
#   clustering_methods = "hierarchical", # Options: "both", "hierarchical", "custom", or c("hierarchical", "custom")
#   optimize_group_count = FALSE, # Reducing total groups is time-consuming, only apply for final config
#   optimize_distances = FALSE, # Minize distances (make group more compact) is time-consuming, only apply for final config
#   parallel = TRUE,
#   verbose = TRUE # Print progress after each config
# )

```

```{r print-comparison-summary}
# # View full results table
# print(comparison)

# # Find overall best (fewest groups across both methods)
# min_h <- min(comparison$n_groups_hierarchical)
# min_c <- min(comparison$n_groups_custom)

# if (min_h < min_c) {
#   cat("Winner: Hierarchical with", min_h, "groups\n")
#   best <- comparison[which.min(comparison$n_groups_hierarchical), ]
# } else {
#   cat("Winner: Custom with", min_c, "groups\n")
#   best <- comparison[which.min(comparison$n_groups_custom), ]
# }
# print(best)

# # Compare averages (consistency check)
# cat("\nAverage groups:\n")
# cat("  Hierarchical:", mean(comparison$n_groups_hierarchical), "\n")
# cat("  Custom:", mean(comparison$n_groups_custom), "\n")

# # Speed comparison
# cat("\nAverage time:\n")
# cat("  Hierarchical:", mean(comparison$time_hierarchical_min), "min\n")
# cat("  Custom:", mean(comparison$time_custom_min), "min\n")
```

```{r print-comparison-results}
# Automatically select best configuration
#which_col <- which.min(c(min(comparison$n_groups_hierarchical), min(comparison$n_groups_custom)))
#which_method <- c("cluster_hierarchical", "cluster_custom")[which_col]
#which_order <- comparison$ordering_method[which.min(comparison[, (which_col + 1)])]
#reversed <- comparison$reversed[which.min(comparison[, (which_col + 1)])]


which_method <- "cluster_custom"
which_order <- "east-west"
reversed <- TRUE

cat("Selected best configuration:\n")
cat("  Clustering method:", which_method, "\n")
cat("  Ordering method:", which_order, "\n")
cat("  Reversed:", reversed, "\n\n")

# Hardcoded best configuration (from previous analysis)


# Run grouping with optimal configuration
grouped_lynx <- group_lynx_families(
  data = dat,
  clustering_method = which_method,
  ordering_method = which_order,
  reversed = reversed,
  optimize_group_count = TRUE, # Minimize total number of family groups (previously pretty_groups())
  optimize_distances = TRUE, # Minimize distances within family groups (more spatially compact groups, previously pretty_lines())
  group_col = "gruppe_id"
)

cat("Grouping results:\n")
cat("  Total groups:", length(unique(grouped_lynx$gruppe_id)), "\n")
cat("  Total observations:", nrow(grouped_lynx), "\n")

# Verify the grouping worked correctly
cat("\nGrouping verification:\n")
cat("  Unique gruppe_id values:", length(unique(grouped_lynx$gruppe_id)), "\n")
cat("  Min gruppe_id:", min(grouped_lynx$gruppe_id, na.rm = TRUE), "\n")
cat("  Max gruppe_id:", max(grouped_lynx$gruppe_id, na.rm = TRUE), "\n")
cat("  Any NA groups?:", any(is.na(grouped_lynx$gruppe_id)), "\n\n")

# Group size distribution (detailed)
group_sizes <- table(grouped_lynx$gruppe_id)
cat("Group sizes (observations per group):\n")
for (i in seq_along(group_sizes)) {
  cat("  Group", names(group_sizes)[i], ":", group_sizes[i], "observations\n")
}
cat("\n")
```


## 4. Create Visualization Objects

```{r create-viz-objects}
# Extract group assignments (rovbase_id: gruppe_id)
group_assignments <- grouped_lynx %>%
  st_drop_geometry() %>%
  select(rovbase_id, gruppe_id) %>%
  mutate(rovbase_id = as.character(rovbase_id))

# Join group assignments to "original" observations dataset for visualization
lynx_family_observations <- obs_pnt %>%
  mutate(rovbase_id = as.character(rovbase_id)) %>%
  left_join(group_assignments, by = "rovbase_id")

# Ensure CRS is preserved
if (is.na(st_crs(lynx_family_observations))) {
  lynx_family_observations <- st_set_crs(lynx_family_observations, st_crs(dat))
}

# Calculate group centers (centroids) based on clustered observations
lynx_family_group_centers <- create_center_points(
  data = grouped_lynx,
  group_col = "gruppe_id"
)

# Ensure CRS for centers
if (is.na(st_crs(lynx_family_group_centers))) {
  lynx_family_group_centers <- st_set_crs(lynx_family_group_centers, st_crs(dat))
}

cat("Group centers calculated:\n")
cat("  Number of centers:", nrow(lynx_family_group_centers), "\n")
cat("  Expected (unique groups):", length(unique(grouped_lynx$gruppe_id)), "\n")
print(lynx_family_group_centers)

# Create lines connecting observations to group centers
lynx_family_group_lines <- create_lines(
  observations = lynx_family_observations, # Observations with gruppe_id
  centers = lynx_family_group_centers, # Group centroids
  group_col = "gruppe_id"
)

# Ensure CRS for lines and add gruppe_id back
if (is.na(st_crs(lynx_family_group_lines))) {
  lynx_family_group_lines <- st_set_crs(lynx_family_group_lines, st_crs(dat))
}
lynx_family_group_lines$gruppe_id <- lynx_family_observations$gruppe_id[match(lynx_family_group_lines$rovbase_id, lynx_family_observations$rovbase_id)]

cat("\nConnection lines created:\n")
cat("  Total lines:", nrow(lynx_family_group_lines), "\n")
```

## 5. Interactive Map Visualization

```{r visualize-map, fig.width=10, fig.height=8}
# Check and set CRS if missing (use same CRS as dat)
if (is.na(st_crs(lynx_family_observations))) {
  lynx_family_observations <- st_set_crs(lynx_family_observations, st_crs(dat))
}
if (is.na(st_crs(lynx_family_group_centers))) {
  lynx_family_group_centers <- st_set_crs(lynx_family_group_centers, st_crs(dat))
}
if (is.na(st_crs(lynx_family_group_lines))) {
  lynx_family_group_lines <- st_set_crs(lynx_family_group_lines, st_crs(dat))
}

# Transform to WGS84 for leaflet
grouped_wgs84 <- st_transform(lynx_family_observations, 4326)
centers_wgs84 <- st_transform(lynx_family_group_centers, 4326)
lines_wgs84 <- st_transform(lynx_family_group_lines, 4326)

# Create color palette
n_groups_final <- length(unique(grouped_wgs84$gruppe_id))
pal <- colorFactor(viridis(n_groups_final, option = "turbo"), domain = grouped_wgs84$gruppe_id)

# Create interactive map
lynx_map <- leaflet() %>%
  addProviderTiles(providers$OpenTopoMap) %>%
  addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>%
  # Add connection lines
  addPolylines(
    data = lines_wgs84,
    color = ~ pal(gruppe_id),
    weight = 3,
    opacity = 0.8
  ) %>%
  # Add observation points
  addCircleMarkers(
    data = grouped_wgs84,
    color = "black",
    fillColor = ~ pal(gruppe_id),
    fillOpacity = 0.8,
    radius = 6,
    stroke = TRUE,
    weight = 2,
    popup = ~ paste0(
      "<strong>Observation ID:</strong> ", rovbase_id, "<br>",
      "<strong>Group:</strong> ", gruppe_id, "<br>",
      "<strong>Prey:</strong> ", byttedyr, "<br>",
      "<strong>Date:</strong> ", format(datotid_fra, "%Y-%m-%d")
    ),
    label = ~ as.character(rovbase_id)
  ) %>%
  # Add group centers
  addCircleMarkers(
    data = centers_wgs84,
    color = "red",
    fillColor = "red",
    fillOpacity = 1,
    radius = 8,
    stroke = TRUE,
    weight = 2,
    popup = ~ paste0("<strong>Group Center</strong><br>Group ID: ", gruppe_id),
    label = ~ paste("Group", gruppe_id)
  ) %>%
  # Add controls
  addLayersControl(
    baseGroups = c("OpenTopoMap", "Satellite"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addScaleBar(position = "bottomleft") %>%
  addMeasure(primaryLengthUnit = "meters", primaryAreaUnit = "sqmeters")

# Display map
lynx_map
```

## 7. Export Results

```{r export-results}
# Create output directory if it doesn't exist
output_dir <- file.path(base_path, "output")
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

# Save to GeoPackage (recommended for spatial data)
st_write(
  grouped_lynx,
  file.path(output_dir, "lynx_family_group_observations_migrated.gpkg"),
  delete_dsn = TRUE,
  quiet = TRUE
)

st_write(
  lynx_family_group_centers,
  file.path(output_dir, "lynx_family_group_centers_migrated.gpkg"),
  delete_dsn = TRUE,
  quiet = TRUE
)

st_write(
  lynx_family_group_lines,
  file.path(output_dir, "lynx_family_group_lines_migrated.gpkg"),
  delete_dsn = TRUE,
  quiet = TRUE
)

cat("Spatial data saved to GeoPackage:\n")
cat("  -", file.path(output_dir, "lynx_family_group_observations_migrated.gpkg"), "\n")
cat("  -", file.path(output_dir, "lynx_family_group_centers_migrated.gpkg"), "\n")
cat("  -", file.path(output_dir, "lynx_family_group_lines_migrated.gpkg"), "\n\n")

# Save as CSV (without geometry)
results_table <- grouped_lynx %>%
  st_drop_geometry() %>%
  select(rovbase_id, datotid_fra, datotid_til, byttedyr, gruppe_id)

write.csv(
  results_table,
  file.path(output_dir, "lynx_family_group_assignments_migrated.csv"),
  row.names = FALSE
)

cat("Tabular data saved to CSV:\n")
cat("  -", file.path(output_dir, "lynx_family_group_assignments_migrated.csv"), "\n\n")

# Save comparison results (if comparison was run)
# write.csv(
#   comparison,
#   file.path(output_dir, "sensitivity_analysis_migrated.csv"),
#   row.names = FALSE
# )
# 
# cat("Sensitivity analysis saved:\n")
# cat("  -", file.path(output_dir, "sensitivity_analysis_migrated.csv"), "\n\n")

# Save interactive map
saveWidget(
  lynx_map,
  file = file.path(output_dir, "lynx_family_groups_map_migrated.html"),
  selfcontained = TRUE
)

cat("Interactive map saved:\n")
cat("  -", file.path(output_dir, "lynx_family_groups_map_migrated.html"), "\n")
```

```{r-session-info}
sessionInfo()
```